I = vector.new(1,0,0)
J = vector.new(0,1,0)
K = vector.new(0,0,1)

-- Get location of computer using rednet
function getLocation()
    local loc = vector.new(gps.locate(5))
    if not loc then
        return true, nil
        -- We return error = true and loc = nil
    else
        return false, loc
    end
end

-- Get orientation of turtle (if localMode, 
-- then use the turtle's stored direction)
function getOrientation(localMode)
    
    if not turtle then
        return nil
        -- Computers don't have an orientation
    end

    if not localMode then

        -- We note that getting location non-locally costs fuel, so before we do anything, we yield the process
            -- to check whether we have sufficient fuel.
        coroutine.yield()
        
        local err, loc1 = getLocation()
        -- Now we'll move the turtle

        local delta_y = 0
        local loc2_ready = false
        -- We need to move the turtle to get a displacement vector to calculate orientation
        -- so we need to make sure that the turtle can move forward

        repeat
            if turtle.forward() then
                loc2_ready = true
            else
                if turtle.up() then
                    delta_y = delta_y + 1
                else 
                    if turtle.digUp() then
                        turtle.up()
                        delta_y = delta_y + 1
                    else
                        loc2_ready = true
                        -- We failed to find an opening to get orientation. Let's abort
                        -- At this point, if we want to improve the gps code, we'd tell the robot to return to
                        -- it's original position, then have it mine the block in front of it to create an opening.
                        -- We'd want to check to see if the block in front is valuable however...
                    end
                end
            end
        until loc2_ready

        if loc2_ready then
            err, loc2 = getLocation()
        else
            loc2 = loc1
            -- Something weird happened, let's abort.
        end

        -- Now move back down
        turtle.back()
        for i=1,delta_y,1 do
            turtle.down()
        end

        local disp = loc2 - loc1
        -- We don't care about the vertical component
        disp.y = 0

        return disp
    else 
        -- This is localMode == true
        return local_orientation
    end
end

-- Initialize local_orientation vector
local_orientation = getOrientation(false)

-- Calculate the vector trajectory between destination from current location
function getTrajectory(dest)
    local err, loc = getLocation()
    if not err then
        return false, dest - loc
    else
        return true, vector.new(0,0,0)
        -- Don't send displacement if there is an error
    end
end

-- Rotate until turtle matches given orientation
function orientTurtle(direction, localMode)
    -- Let's make sure the direction vector is nonzero
    if direction:length() > 0 then
        if localMode then
            if not (direction:dot(local_orientation) > 0) then
                repeat
                    turtle.turnRight()
                    -- Rotate the orientation vector Ï€/2 radians in xz plane.
                    local x_prime = -1 * local_orientation.z
                    local z_prime =  local_orientation.x

                    local_orientation.x = x_prime
                    local_orientation.z = z_prime

                until (direction:dot(local_orientation) > 0)
            end
        else
            if not (direction:dot(getOrientation()) > 0) then
                repeat
                    turtle.turnRight()
                until (direction:dot(getOrientation()) > 0)
            end
        end
        local_orientation = direction
    end
end

-- In order to deal with event handling higher up, we need to write helper functions
--      that yield the current coroutine before moving each block. Essentially, we are
--      creating a parallel system where the robot checks auxiliary functions after
--      moving a single block. That way, we can deal with event interrupts, etc..

local forward =function ()
    coroutine.yield()
    return turtle.forward()
end

local up = function ()
    coroutine.yield()
    return turtle.up()
end

local down = function ()
    coroutine.yield()
    return turtle.down()
end


-- Travel down trajectory vector
function traverseTrajectory(trajectory, breakBlocks)
    
    local dx = trajectory.x
    local dy = trajectory.y
    local dz = trajectory.z

    local sign_x = dx/math.abs(dx)
    local sign_y = dy/math.abs(dy)
    local sign_z = dz/math.abs(dz)

    -- Move in x first
    if (dx ~= 0) then
        orientTurtle(I:mul(sign_x), true)
        for i = 1,math.abs(dx) do
            if not forward() then
                if breakBlocks then
                    turtle.dig()
                    forward()
                end
            end
        end
    end

    -- Move in z now
    if (dz ~= 0) then
        orientTurtle(K:mul(sign_z), true)
        for i = 1,math.abs(dz) do
            if not forward() then
                if breakBlocks then
                    turtle.dig()
                    forward()
                end
            end
        end
    end

    -- Move in y
    if (sign_y) > 0 then
        for i = 1,math.abs(dy) do
            if not up() then
                if breakBlocks then
                    turtle.digUp()
                    up()
                end
            end
        end
    elseif (sign_y) < 0 then
        for i = 1,math.abs(dy) do
            if not down() then
                if breakBlocks then
                    turtle.digDown()
                    down()
                end
            end
        end
    end
end

-- Go to location (takes a 3 vector for destination). Tolerance is the
-- maximum distance from destination allowed
function goto(destination, _breakBlocks, _tolerance)

    local trajectory = nil
    local breakBlocks = _breakBlocks or false
    local tolerance = _tolerance or 1

    repeat
        err, trajectory = getTrajectory(destination)
        
        if not err then
            traverseTrajectory(trajectory, breakBlocks)
        else
            print('Failed to get trajectory, aborting goto to '.. trajectory:tostring())
            break
        end

    until trajectory:length() < tolerance
    -- FIX ME until trajectory:round():length() < tolerance
end

function orientChunk()
    local err, loc = getLocation()
    if not err then
        goto(vector.new(loc.x % 16, loc.y % 16, loc.z % 16), true)
        orientTurtle(I, true)
        
    end
end

    


