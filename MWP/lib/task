-- This is the API dedicated to handling tasks, listeners, and the tasks queue.
    -- Why is the API not called "events" then? -BREVAN
        -- Ssshhhhhhhh - Anthony

-- FIXME? Should we consolidate the code from act into this?
    -- No. The act code is deprecated. We need to rewrite our
    -- fuel listeners and storage listeners into the new paradigm. - Anthony

print('Entered task')
print('Loading listener class.')
listener = {

    name = 'untitled_listener',
    -- Let's enable the listener by default
    enabled = true,
    terminate = false,

    checkCondition = function (self)
        -- This function is called by self:listen().
            -- This function should check for a certain condition. If the
            -- conditions are satisfied, this should return true, else return false.
        print('Default condition for listener.')
        return true
    end,

    listen_coroutine = coroutine.create(function (self, ...)
        -- This function is called by the task handler
        print('Entered the listen coroutine for ' .. self.name)
        local result
        repeat
            print('Reached if statement for ' .. self.name)
            if self:checkCondition() then
                print('Executing task for ' .. self.name)
                self.status = 'triggered'
                ok, result = self:executeTask(...)
                --ok = 'null'
                --result = 'NULLRESULT'
                print('Ran executeTask, ok? ')
                print(ok)
            else
                print('Condition for ' .. self.name .. ' returned false.')
                result = false
            end

        -- terminate is a property that determines whether the listener should finish listening.
        -- i.e. when terminate is true, the loop will stop, and the coroutine will become dead,
        -- so the task handler will remove it from the queue.

        -- Now we yield the listen coroutine. This passes control back to the taskHandler.
                -- The next time this listener is called, the condition in this repeat loop will be checked,
                -- and if self.terminate == true, the loop will terminate entirely and the listen_coroutine
                -- will die.
            coroutine.yield(result)
        until self.terminate == true

        self.status = 'terminated'
        print('Exited repeating loop for ' .. self.name)
    end),

    listen = function (self, ...)
        self.status = 'listening'
        print('LISTENING: ' .. self.name)
        local ok, result = coroutine.resume(self.listen_coroutine, self, ...)
        print('Status of ' .. self.name .. '.listen_coroutine: ' .. coroutine.status(self.listen_coroutine) )
        return result
    end,

    task_co = coroutine.create(function (self, ...)
        print('Default executeTask for listener.')
        -- This function is called by self:listen() when condition returns true.
    end),

    executeTask = function(self,...)
        return coroutine.resume(self.task_co, self, ...)
    end
}

print('Loading listener constructor.')
function listener:new(_name, _conditon, _task, _runOnce)
    
    local obj = {
        status = 'new',
        enabled = true,
        name = _name,
        terminate = _runOnce,

        checkCondition = function(thisListener)
            if thisListener.enabled then
                return _conditon(thisListener)
            else
                return false
            end
        end,

        task_co = coroutine.create(_task)
    }

    setmetatable(obj, self)
    self.__index = self

    return obj
end

print('Loading taskHandler class.')
taskHandler = {

    name = 'untitled_task_handler',

    listeners = {},
    deadListeners = {},

    intermediateTask = function (self, ...)
        -- This function is ran after each time a listener yields. This may be the key to running critical events or nesting event listeners.
        print('Default intermediateTask')
    end,

    addListener = function(self, listener)
        self.listeners[listener.name] = listener
    end,

    removeListener = function(self, listener)
        if self.listeners[listener.name] then
            table.insert(self.deadListeners,listener)
        end
    end,

    run = function(self, ...)
        -- Here we cycle through all events in this taskHandler.

        -- Now we delete dead listeners
        for _,L in ipairs(self.deadListeners) do
            self.listeners[L.name] = nil
        end

        local result

        for listenerName, L in pairs(self.listeners) do

            if listenerName then
              print('CHECKING   -->' .. listenerName)
            else
              print('Null listener in ' .. self.name)
            end

            result = L:listen(...)

            print('Received result from listener: ')
            print(result)

            if coroutine.status(L.listen_coroutine) == 'dead' then
                print('DELETE LISTENER ' .. L.name .. '!')
                self:removeListener(L)
            end

            self:intermediateTask()
        end
    end,

    start = function(self,...)
        self.enabled = true

        while self.enabled do
            print('Starting ' .. self.name .. ':run(...)')
            self:run(...)
            print('Reached end of loop, task:118.')
        end

        return 'process_completed'
    end,

    stop = function(self, ...)
        self.enabled = false
    end
}

print('Loading taskHandler constructor.')
function taskHandler:new( _listeners, _intermediateTask, _name)
    local obj = {
        name = _name or 'untitled_task_handler',
        enabled = false,
        listeners = _listeners,
        intermediateTask = _intermediateTask

    }

    setmetatable(obj, self)
    self.__index = self

    return obj
end

print('Loading noYield function.')
function noYield(func)
  print('Executing noYield')
    -- Takes a function that calls coroutine.yield() and continues resuming the function so that
    -- to ignore coroutine.yield().
	local co
    if type(func) == 'coroutine' then
        co = func
    elseif type(func) == 'function' then
        print('Created coroutine from function')
        co = coroutine.create(func)
    else
        error('noYield needs either a coroutine or function as an argument!')
    end

    local noYieldFunction = function (...)
        local status
        repeat
            status = coroutine.resume(co, ...)
        until coroutine.status(co) == 'dead'
    end

    print('returning noYieldFunction')
    return noYieldFunction
end

print('Completed task API')
