-- This api requires the gps api
local LIB_GPS_PATH = 'SkyNet/MWP/lib/gps2'
os.loadAPI(LIB_GPS_PATH)

waypoint = {
    updateLocation = function(self)
                        local err, loc = gps2.getLocation()
                        if not err then
                            self.location = loc
                        else
                            self.err = true
                        end
                    end,
    go = function(self, tolerance, breakBlocks)
                previous_location:updateLocation()
                gps2.goto(self.location, tolerance, breakBlocks)
            end
}

function waypoint:new(_name, loc)
    --Lua constructors scare me.
    local obj = {
        name = _name or 'untitled_waypoint',
        location = loc or vector.new(0,0,0),
        err = false
    }
    setmetatable(obj, self)
    self.__index = self
    return obj
end

-- We create this global variable so that we may work with the robot's prior location
local err, loc = gps2.getLocation()
if not err then
    previous_location = waypoint:new('Previous_Location', loc)
else
    previous_location = waypoint:new('Previous_Location', vector.new(0,0,0))
end

-- Let's create some basic properties of the path class
path = {
    waypoints = {},
    name = '__proto__path',
    append = function(self,waypoint)
                table.insert(self.waypoints,waypoint)
            end,
    pop = function(self)
                table.remove(self.waypoints)
            end,
    start = function(self, tolerance, breakBlocks)
                print('Starting path ' .. self.name)
                local begin = coroutine.wrap(function()
                    for i = self.currentWaypointNumber, #self.waypoints do
                        -- Now that we jumped to the latest waypoint, we are good
                        self.currentWaypointNumber = i + 1
                        print('In for loop')
                        waypoint[i]:go(tolerance,breakBlocks)
                        
                        coroutine.yield()
                    end
                    self.currentWaypointNumber = 0
                    return 0
                end)

                local stop = coroutine.wrap(function()
                    -- waitForAny() returns the numner corresponding to whether the first or second argument terminated first
                    local reason = parallel.waitForAny(os.pullEvent('stop_' .. self.name), os.pullEvent('pause_' .. self.name))

                    if (reason == 1) then
                        self.currentWaypointNumber = 0
                    end

                    coroutine.yield()

                    return 0
                end)
                -- This uses computercraft's parallel api to traverse the path of waypoints. But if someone calls self.stop(), then we're done.
                begin()
                stop()
            end,
    stop = function(self)
                os.queueEvent('stop_' .. self.name)
                return 0
            end,
    pause = function(self)
                os.queueEvent('pause_' .. self.name)
                return 0
            end
}

function path:new(_name, _waypoints)
    local obj = {
        name = _name or "untitled_path",
        waypoints = _waypoints or {},
        -- If the path was paused, this is nonzero.
        currentWaypointNumber = 0
    }
    setmetatable(obj,self)
    self.__index = self
    return obj
end


