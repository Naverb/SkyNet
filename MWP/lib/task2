--[[ 
    This is the new API to handle tasks (listeners) and taskSequences (taskHandlers). We found the previous API had some major shortcomings, including:
    1) When a function yielded within a listener, the task_co would intercept the yield before the BIOS coroutine could receive the event. This prevented APIs like GPS, GPS2, and rednet from working.
    2) We needed to modify attributes of a parent taskHandler from within a specific listener. So we need to find a clean and simple way to pass a parent object (taskSequence) to child objects (task).
]]

--[[ 
    Description of control flow in handy-dandy natural language:

    taskFoo: Hi, to finish my action, I need resumeEvent.
    PTS (parent task sequence): Ok, let me see if I have a task that gives you that...
        (if yes): here, taskBar promises reigsteredOutcome resumeEvent. Let me run it real quick and get back to you.
        (if no): sorry, I need to ask someone else. You'll have to wait a bit.
    PTS (to its own parent, PPTS): Hi, I need resumeEvent, can you give me that?
    PPTS: Let me check..
        [ The process repeats until resumeEvent is fullfilled.]
]]


-- Perhaps we want to make both the task and the taskSequence classes extensions of a general, yielding_object class. That way we can write one yielding function for both classes.

yielding_object = {
    name = 'untitled_yielding_object',
    resumeEvent = 'nullEvent', -- We don't want to set this to nil because we don't want to throw an error trying to reference nil, but we do want to differentiate between a task with a specific resumeEvent and one without a nontrivial resumeEvent.
    status = 'cold'
}

setmetatable(yielding_object, yielding_object)
yielding_object.__index = function (t, k)
    -- We probably want to make this function a little more sophisticated.
    error('Yielding object' .. t.name .. ' attempted to access nil value at '.. k .. '.')
end

function yielding_object:registerResumeEvent(resumeEvent, ...)
    -- Yields the yielding object to be intercepted by the parent yielding object. Passes resumeEvent info to notify the parent of the conditions necessary to resume this.
    local parent = self.parent
    parent:unqueueTask(self)
    
    self.resumeEvent = resumeEvent or 'nullEvent' -- If resumeEvent is nullEvent, we assume that this yielding object can be resumed at any time.
    parent:queueTask(self)

    -- Now we hand control back to the parent (see self:run).
    self.status = 'cold'
end

function yielding_object:registerParent(parent)
    -- This method allows us to set the parent taskSequence as a constant attribute of self.

    -- NOTE: This forces parent to be a single table. Hence, the current version of this method does not allow a yielding_object to be registered with more than one parent.
    self.parent = parent -- Consult https://www.lua.org/pil/2.5.html
end

task = {
    name = 'untitled_task',
    registeredOutcome = 'none',
    enabled = true,

    -- This is the default task_co. It's completely useless, but we have it to avoid a nil reference.,
    action = function ()
        return true
    end,

    task_co = coroutine.create(action)
}
setmetatable(task, task)
task.__index = yielding_object -- We tell task to extend yielding_object.


function task:conditon()
    -- This is the default conditon of a task, it just returns true.
    return true
end

function task:checkCondition(event, ...)
    event = event or 'nullEvent'
     -- Now we check if the resumeEvent is satisfied:
    if event == self.resumeEvent and self.enabled then --self.enabled then
            return self:conditon() -- Yes, Brevan, that is *conditon*
    end

    -- If conditon is false, make sure we save passed parameters from the parent sequence, so that we can execute this task ASAP (when conditon is true) when the taskSequence passes a different resumeEvent later on.

    -- If we reach this line we did not receive the event that we needed to resume. This shouldn't happen, so we report it.
    error("Task " .. self.name .. " failed to receive it's proper resume event. Needed " .. self.resumeEvent .. " but received " .. event .. ".")

    -- If the task is not enabled, we do not let the task execute.
    return false
end

function task:run(event, ...)
    -- Starts/resumes the task_co to complete the task's action.
    if self:checkCondition(event) then
        -- Execute task_co, return the results.
        self.latestResults = table.pack(coroutine.resume(self.task_co, self, ...)) -- We pass self so that we can manipulate attributes of the task from within task_co.
        local status = coroutine.status(self.task_co)
        local resumeEvent = self.latestResults[1] -- The first element of latestResults is ALWAYS resumeEvent
        self:registerResumeEvent(resumeEvent)

        return status, table.unpack(self.latestResults)
    else
        -- Report to parent that conditions for this task are not satisfied and task did not run.
        local status = coroutine.status(self.task_co)
        return status
    end
end

function task:registerOutcome(event, ...)
    -- This method is to be called whenever we need to change registeredOutcome of a task after it has been created.
    local parentSequence = self.parent
    -- Sets the promised outcome event (a string) of this task.
    local previousOutcome = self.registeredOutcome
    self.registeredOutcome = event

    -- Notify the taskSequence that this task has a new registeredEvent.
	parentSequence:registerTask(self, previousOutcome)
		--- registerTask updates to new registered outcome, and tells the parent the task is not promising the previousOutcome anymore
end

function task:enable()
    -- Set this task's enabled attribute to true.
    self.enabled = true
end

function task:disable()
    -- Set this task's enabled attribute to false.
    self.enabled = false
end

function task:resurrect(resetResumeEvent)
    -- Recreate the task_co so that it can be executed again (after task_co returns)
    self.task_co = coroutine.create(self.action)

    if resetResumeEvent then
        self.resumeEvent = 'nullEvent'
    end

    return true
end


function task:new(name, action, registeredOutcome)
    --This is the constructor for task.

    -- taskFoo = task:new('foo', function() doStuff() end, 'fooEvent')
    -- taskFoo = task:new('foo', doStuff, 'fooEvent')

    local obj = {}

    setmetatable(obj, obj)
    obj.__index = task -- I think this how we can handle inheritance.

    obj.name = name
    obj.registeredOutcome = registeredOutcome
    -- Here we construct task_co.
    obj.action = action
    obj.task_co = coroutine.create(obj.action)

    return obj
end


taskSequence = {
    name = 'untitled_taskSequence',
    registeredOutcome = 'sequence_status',
    enabled = true,
    tasks = {},
    pendingTasks = {
        -- This table is organized into keys (labelling resumeEvents) that categorize tasks into the resumeEvent they need to run.
        enclosing_task_sequence = taskSequence
    },
    coroutines = {}
}

tasksMt = {
    __index = function(tasksTable, event)
        return function(self, event)
            self:registerResumeEvent(event)
            coroutine.yield(event)
        end, true -- The second parameter is caught and used to determine whether the taskSequence could find a task to satisfy event.
    end
}

setmetatable(taskSequence.tasks, tasksMt) -- This allows us to handle the case where the taskSequence does not contain a task to handle a particular event.

pendingTasksMt = {
    __index = function(k,t)
        print('Attempted to execute tasks of event ' .. k .. 'despite ' .. t .. ' not having any such pending tasks.')
    end
}

setmetatable(taskSequence.pendingTasks, pendingTasksMt)
setmetatable(taskSequence, taskSequence)
taskSequence.__index = task -- We tell taskSequence to extend task.

function taskSequence:queueTask(task)
    -- Add a task to the taskSequence, to be completed after all other tasks in nextTask have been run.
    table.insert(_pendingtasks[task.resumeEvent], task) -- Can we insert to a table that doesn't necessarily exist yet?
    task:registerParent(_pendingtasks.enclosing_task_sequence)

end

function taskSequence:unqueueTask(task)
    table.remove(self.pendingTasks[task.resumeEvent], task.name)
    task:registerParent(_pendingtasks.enclosing_task_sequence)
end

function taskSequence:checkEventFulfillment(event)
    local t, bad = self.tasks[event]
    if not bad then
        return function(self)
            self:queueTask(t)
        end
    else 
        return t 
    end
end

function taskSequence:dispatch(arg)
    local event = arg.event or 'nullEvent'
    local dispatchAll = arg.dispatchAll or false
    if self.enabled then
        self.status = 'hot'

        -- If event is not specified we dispatch all tasks.
        if dispatchAll then
            if not self.allTasks_co or coroutine.status(self.allTasks_co) == 'dead' then
                self:createAllTasksCoroutine()
            end

            self.latestResults = table.pack(coroutine.resume(self.allTasks_co))
            status = coroutine.status(self.allTasks_co)

            return status, table.unpack(self.latestResults)

        else

            if not self.coroutines[event] or coroutine.status(self.coroutines[event]) == 'dead' then
                self:createTaskSequenceCoroutine(event)
            end

            self.latestResults = table.pack(coroutine.resume(self.coroutines[event]))
            status = coroutine.status(self.coroutines[event])

            return status, table.unpack(self.latestResults)

        end
    end
end

taskSequence.run = taskSequence.dispatch -- Create an alias to overwrite run() inherited by the task class.

function taskSequence:registerTask(task, previousOutcome)
    -- Registers a task to its registeredOutcome
    -- Move task to the table self.tasks[task.registeredOutcome]
    self.tasks[previousOutcome] = nil
    self.tasks[task.registeredOutcome] = task --If the key doesn't exist, does this create the key?

    task:registerParent(self)
end

function taskSequence:processTask(task)
    local taskResult = {task:run(event)}

    if taskResult[1] == 'dead' then -- We have detected that the task has finished its task_co.
        task:disable()
        table.remove(self.pendingTasks[task.resumeEvent], task.name)
    elseif taskResult[1] == 'yielded' or taskResult[1] == 'suspended' then -- We have detected that the task is waiting for an event to resume it.
        
        local nextAction = self.checkEventFulfillment[task.resumeEvent]

        nextAction(self) -- Either this will queue the task that fulfills resumeEvent, or it yields the taskSequence so that another yielding_object can try to satisfy the resumeEvent.
    end
end

function taskSequence:createTaskSequenceCoroutine(event)
    -- Creates the coroutine that cycles through all tasks of a given event.
    self.coroutines[event] = coroutine.create(function () -- Do we want to pass self as a parameter? If we don't this creates a closure of self that may not be up-to-date with the current taskSequence.

        for _, task in pairs(self.pendingTasks[event]) do
                self:processTask(task)
        end

    end)
end

function taskSequence:createAllTasksCoroutine()
    self.allTasks_co = coroutine.create(function ()

        for event, sequence in pairs(self.pendingTasks) do
            for _, task in pairs(sequence) do
                self:processTask(task)
            end
        end
    end)
end

function taskSequence:new(name)

    local obj = {}
    obj.name = name
    obj.tasks = {}
    obj.pendingTasks = {
        enclosing_task_sequence = obj
    }
    obj.coroutines = {}

    setmetatable(obj,obj)
    obj.__index = taskSequence

    setmetatable(obj.tasks, tasksMt)
    setmetatable(obj.pendingTasks, pendingTasksMt)

    return obj
end