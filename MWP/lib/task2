--[[ 
    This is the new API to handle tasks (listeners) and taskSequences (taskHandlers). We found the previous API had some major shortcomings, including:
      1) When a function yielded within a listener, the task_co would intercept the yield before the BIOS coroutine could receive the event. This prevented APIs like GPS, GPS2, and rednet from working.
      2) We needed to modify attributes of a parent taskHandler from within a specific listener. So we need to find a clean and simple way to pass a parent object (taskSequence) to child objects (task).
]]--

-- Perhaps we want to make both the task and the taskSequence classes extensions of a general, yielding_object class. That way we can write one yielding function for both classes.

yielding_object = {
    name = 'untitled_yielding_object',
    resumeEvent = 'nullEvent',
    status = 'cold',
    indexInParent = -1 -- This is negative 1 because -1 would never be indexed by the array.
}

setmetatable(yielding_object, yielding_object)
yielding_object.__index = function (t, k)
    -- We probably want to make this function a little more sophisticated.
    error('Yielding object' .. t.name .. ' attempted to access nil value at '.. k .. '.')
end

function yielding_object:yield(resumeEvent, ...)
    -- Yields the yielding object to be intercepted by the parent yielding object. Passes resumeEvent info to notify the parent of the conditions necessary to resume this.
    self.resumeEvent = resumeEvent or 'nullEvent' -- If resumeEvent is nil, we assume that this yielding object can be resumed at any time.
    -- Now we hand control back to self:run or back to the parent (see self:run).
    return coroutine.yield(resumeEvent, ...)
end

function yielding_object:registerParent(parent)
    -- This method allows us to set the parent taskSequence as a constant attribute of self.

    -- NOTE: This forces parent to be a single table. Hence, the current version of this method does not allow a yielding_object to be registered with more than one parent.
    self.parent = parent -- Consult https://www.lua.org/pil/2.5.html
    self.indexInParent = nil -- Fix this?
end

task = {
    name = 'untitled_task',
    registeredOutcome = 'none',
    resumeEvent = 'nullEvent', -- We don't want to set this to nil because we don't want to through an error trying to reference nil, but we do want to differentiate between a task with a specific resumeEvent and one without a nontrivial resumeEvent.
    enabled = true,

    -- This is the default task_co. It's completely useless, but we have it to avoid a nil reference.
    task_co = coroutine.create(function () return true end)
}


setmetatable(task, task)
task.__index = yielding_object -- We tell task to extend yielding_object.

function task:conditon()
    -- This is the default conditon of a task, it just returns true.
    return true
end

function task:checkCondition(event, ...)
    event = event or 'nullEvent'
     -- Now we check if the resumeEvent is satisfied:
    if event == self.resumeEvent and self.enabled then --self.enabled then
            return self:conditon() -- Yes, Brevan, that is *conditon*
    end
    -- If we reach this line we did not receive the event that we needed to resume. This shouldn't happen, so we report it.
    error("Task " .. self.name .. " failed to receive it's proper resume event. Needed " .. self.resumeEvent .. " but received " .. event .. ".")

    -- If the task is not enabled, we do not let the task execute.
    return false
end

function task:run(event, ...)
    -- Starts/resumes the task_co to complete the task's action.
    if self:checkCondition(event) then
        -- Execute task_co, return the results.
        self.latestResults = table.pack(coroutine.resume(self.task_co, self, ...)) -- We pass self so that we can manipulate attributes of the task from within task_co.
        local status = coroutine.status(self.task_co)

        return status, table.unpack(self.latestResults)
    else
        -- Report to parent that conditions for this task are not satisfied and task did not run.
    end
end

function task:registerOutcome(event, ...)
    -- This method is to be called whenever we need to change registeredOutcome of a task after it has been created.
    local parentSequence = self.parent
    -- Sets the promised outcome event (a string) of this task.
    self.registeredOutcome = event
    -- Notify the taskSequence that this task has a new registeredEvent.
    parentSequence:registerTask(self)
end

function task:enable()
    -- Set this task's enabled attribute to true.
    self.enabled = true
end

function task:disable()
    -- Set this task's enabled attribute to false.
    self.enabled = false
end

function task:new(name, action, registeredOutcome)
    --This is the constructor for task.
    local obj = {}

    setmetatable(obj, obj)
    obj.__index = task -- I think this how we can handle inheritance.

    obj.name = name
    obj.registeredOutcome = registeredOutcome
    -- Here we construct task_co.
    obj.task_co = coroutine.create(action)

    return obj
end

taskSequence = {
    name = 'untitled_taskSequence',
    registeredOutcome = 'sequence_status',
    enabled = true,
    tasks = {},
    pendingTasks = {}
}

tasksMt = {
    __index = function(tasksTable, event)
        return function(self, event)
            self:yield(event)
        end, true -- The second parameter is caught and used to determine whether the taskSequence could find a task to satisfy event.
    end
}

setmetatable(taskSequence.task, tasksMt) -- This allows us to handle the case where the taskSequence does not contain a task to handle a particular event.

pendingTasksMt = {
    __add = function (_pendingtasks,task)
        table.insert(_pendingtasks, task)
        task:registerParent(_pendingtasks)

        return _pendingtasks
    end
}

setmetatable(taskSequence.pendingTasks, pendingTasksMt) --This allows us to do some cool syntactical sugar.

setmetatable(taskSequence, taskSequence)
taskSequence.__index = task -- We tell taskSequence to extend task.

function taskSequence:queueTask(task)
    local newSequence = self.pendingTasks + task
    -- Add a task to the taskSequence, to be completed after all other tasks in nextTask have been run.
end

function checkEventFulfillment(event)
    local taskOrFunc, checkFailure = self.tasks[event]
    if not checkFailure then
        return function(self)
            self:queueTask(taskOrFunc)
        end
    else 
        return taskOrFunc 
    end
end

function taskSequence:run(event)
    -- Iterates through nextTask and runs tasks.
    if self.enabled then
        self.status = 'hot'

        -- Pull the next task from the stack:
        for i, task in ipairs(self.pendingTasks) do
            local taskResult = {task:run(event)}

            if taskResult[1] == 'dead' then -- We have detected that the task has finished its task_co.
                task:disable()
                -- We probably want to remove the task from the task sequence now.
            elseif taskResult[1] == 'yielded' then -- We have detected that the task is waiting for an event to resume it.
                -- Do we want to yield the taskSequence right now to satisfy the event condition needed for the yielded task, or do we complete the rest of pendingTasks in order to maximize the amount of tasks done before yielding?
                
                local nextAction = self.checkEventFulfillment[task.resumeEvent]

                nextAction(self) -- Either this will queue the task that fulfills resumeEvent, or it yields the taskSequence so that another yielding_object can try to satisfy the resumeEvent.
            end

            -- Here we need to process taskResult to determine how task yielded/terminated. Does it need to resume? What event does it need for resumeEvent? Is there any other important information stored in taskResult?
        end
    end

end

function taskSequence:registerTask(task)
    -- Registers a task to its registeredOutcome
    -- Move task to the table self.tasks[task.registeredOutcome]
    table.insert(self.tasks[task.registeredOutcome], task)
end

function taskSequence:new()
    --This is the constructor for taskSequence. I think we should extend the task class to make taskSequence. That way, we can yield the taskSequence and insert it into large taskSequences.

    -- Make sure to construct the coroutine to handle the tasks.

end