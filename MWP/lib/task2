--[[ 
    This is the new API to handle tasks (listeners) and taskSequences (taskHandlers). We found the previous API had some major shortcomings, including:
    1) When a function yielded within a listener, the task_co would intercept the yield before the BIOS coroutine could receive the event. This prevented APIs like GPS, GPS2, and rednet from working.
    2) We needed to modify attributes of a parent taskHandler from within a specific listener. So we need to find a clean and simple way to pass a parent object (taskSequence) to child objects (task).
]]--

--[[ 
    Description of control flow in handy-dandy natural language:

    taskFoo: Hi, to finish my action, I need resumeEvent.
    PTS (parent task sequence): Ok, let me see if I have a task that gives you that...
        (if yes): here, taskBar promises reigsteredOutcome resumeEvent. Let me run it real quick and get back to you.
        (if no): sorry, I need to ask someone else. You'll have to wait a bit.
    PTS (to its own parent, PPTS): Hi, I need resumeEvent, can you give me that?
    PPTS: Let me check..
        [ The process repeats until resumeEvent is fullfilled.]
]]--


-- Perhaps we want to make both the task and the taskSequence classes extensions of a general, yielding_object class. That way we can write one yielding function for both classes.

yielding_object = {
    name = 'untitled_yielding_object',
    resumeEvent = 'nullEvent',
    status = 'cold'
}

setmetatable(yielding_object, yielding_object)
yielding_object.__index = function (t, k)
    -- We probably want to make this function a little more sophisticated.
    error('Yielding object' .. t.name .. ' attempted to access nil value at '.. k .. '.')
end

function yielding_object:yield(resumeEvent, ...)

    local previousResumeEvent = self.resumeEvent
    local parent = self.parent
    -- Yields the yielding object to be intercepted by the parent yielding object. Passes resumeEvent info to notify the parent of the conditions necessary to resume this.
    self.resumeEvent = resumeEvent or 'nullEvent' -- If resumeEvent is nil, we assume that this yielding object can be resumed at any time.

    -- IT'S CRITICAL THAT THE TASK HAS A PARENT FOR THESE NEXT FEW TASKS TO EVEN MAKE SENSE.
    -- Otherwise, the metatable for yielding_object should catch the nil reference error, so no hard feelings if a task or taskSequence does not have a parent.

    table.remove(parent.pendingTasks[previousResumeEvent], self.name) -- Is this the correct syntax?
    parent.pendingTasks[self.resumeEvent][self.name] = self -- Essentially, we are moving the current task to the proper category of the parent's pendingTasks table.

    -- Now we hand control back to self:run or back to the parent (see self:run).
    return coroutine.yield(resumeEvent, ...)
end

function yielding_object:registerParent(parent)
    -- This method allows us to set the parent taskSequence as a constant attribute of self.

    -- NOTE: This forces parent to be a single table. Hence, the current version of this method does not allow a yielding_object to be registered with more than one parent.
    self.parent = parent -- Consult https://www.lua.org/pil/2.5.html
    self.indexInParent = nil -- Fix this?
end

task = {
    name = 'untitled_task',
    registeredOutcome = 'none',
    resumeEvent = 'nullEvent', -- We don't want to set this to nil because we don't want to through an error trying to reference nil, but we do want to differentiate between a task with a specific resumeEvent and one without a nontrivial resumeEvent.
    enabled = true,

    -- This is the default task_co. It's completely useless, but we have it to avoid a nil reference.,
    action = function ()
        return true
    end,

    task_co = coroutine.create(action)
}



setmetatable(task, task)
task.__index = yielding_object -- We tell task to extend yielding_object.

function task:conditon()
    -- This is the default conditon of a task, it just returns true.
    return true
end

function task:checkCondition(event, ...)
    event = event or 'nullEvent'
     -- Now we check if the resumeEvent is satisfied:
    if event == self.resumeEvent and self.enabled then --self.enabled then
            return self:conditon() -- Yes, Brevan, that is *conditon*
    end

    -- If conditon is false, make sure we save passed parameters from the parent sequence, so that we can execute this task ASAP (when conditon is true) when the taskSequence passes a different resumeEvent later on.

    -- If we reach this line we did not receive the event that we needed to resume. This shouldn't happen, so we report it.
    error("Task " .. self.name .. " failed to receive it's proper resume event. Needed " .. self.resumeEvent .. " but received " .. event .. ".")

    -- If the task is not enabled, we do not let the task execute.
    return false
end

function task:run(event, ...)
    -- Starts/resumes the task_co to complete the task's action.
    if self:checkCondition(event) then
        -- Execute task_co, return the results.
        self.latestResults = table.pack(coroutine.resume(self.task_co, self, ...)) -- We pass self so that we can manipulate attributes of the task from within task_co.
        local status = coroutine.status(self.task_co)

        return status, table.unpack(self.latestResults)
    else
        -- Report to parent that conditions for this task are not satisfied and task did not run.
    end
end

function task:registerOutcome(event, ...)
    -- This method is to be called whenever we need to change registeredOutcome of a task after it has been created.
    local parentSequence = self.parent
    -- Sets the promised outcome event (a string) of this task.
    local previousOutcome = self.registeredOutcome
    self.registeredOutcome = event

    -- Note, events are returned when tasks are yielded (at least, that's the intention), so a task's registeredOutcome may change as the task yields and resumes. Keep this in mind, make sure the parent knows that the task is updating it's registeredOutcome.

    -- Notify the taskSequence that this task has a new registeredEvent.
    parentSequence:registerTask(self, previousOutcome)
end

function task:enable()
    -- Set this task's enabled attribute to true.
    self.enabled = true
end

function task:disable()
    -- Set this task's enabled attribute to false.
    self.enabled = false
end

function task:resurrect(resetResumeEvent)
    -- Recreate the task_co so that it can be executed again (after task_co returns)
    self.task_co = coroutine.create(self.action)

    if resetResumeEvent then
        self.resumeEvent = 'nullEvent'
    end

    return true
end


function task:new(name, action, registeredOutcome)
    --This is the constructor for task.

    -- taskFoo = task:new('foo', function() doStuff() end, 'fooEvent')
    -- taskFoo = task:new('foo', doStuff, 'fooEvent')

    local obj = {}

    setmetatable(obj, obj)
    obj.__index = task -- I think this how we can handle inheritance.

    obj.name = name
    obj.registeredOutcome = registeredOutcome
    -- Here we construct task_co.
    obj.action = action
    obj.task_co = coroutine.create(obj.action)

    return obj
end


taskSequence = {
    name = 'untitled_taskSequence',
    registeredOutcome = 'sequence_status',
    enabled = true,
    tasks = {},
    pendingTasks = {
        taskSequence = taskSequence
        -- This table is organized into keys (labelling resumeEvents) that categorize tasks into the resumeEvent they need to run.
    }
}

tasksMt = {
    __index = function(tasksTable, event)
        return function(self, event)
            self:yield(event)
        end, true -- The second parameter is caught and used to determine whether the taskSequence could find a task to satisfy event.
    end
}

setmetatable(taskSequence.tasks, tasksMt) -- This allows us to handle the case where the taskSequence does not contain a task to handle a particular event.

pendingTasksMt = {
    __add = function (_pendingtasks,task)

        table.insert(_pendingtasks[task.resumeEvent], task) -- Can we insert to a table that doesn't necessarily exist yet?
        task:registerParent(_pendingtasks.taskSequence)

        return _pendingtasks
    end,

    __index = function(k,t)
        print('Attempted to execute tasks of event ' .. k .. 'despite ' .. t .. ' not having any such pending tasks.')
    end
}

setmetatable(taskSequence.pendingTasks, pendingTasksMt) --This allows us to do some sexy syntactical sugar, sweetie (x5 alliteration combo).

setmetatable(taskSequence, taskSequence)
taskSequence.__index = task -- We tell taskSequence to extend task.

function taskSequence:queueTask(task)
    local newSequence = self.pendingTasks + task
    -- Add a task to the taskSequence, to be completed after all other tasks in nextTask have been run.
end

function taskSequence:checkEventFulfillment(event)
    local taskFunc, bad = self.tasks[event]
    if not bad then
        return function(self)
            self:queueTask(taskFunc)
        end
    else 
        return taskFunc 
    end
end

function taskSequence:run(event)

    -- We need to make this method a coroutine if we are to make a taskSequence a proper yielding_object (i.e. yes).

    -- Iterates through nextTask and runs tasks.
    if self.enabled then
        self.status = 'hot'

        for _, task in pairs(self.pendingTasks[event]) do
            local taskResult = {task:run(event)}

                if taskResult[1] == 'dead' then -- We have detected that the task has finished its task_co.
                    task:disable()
                    -- We probably want to remove the task from the task sequence now.
                elseif taskResult[1] == 'yielded' then -- We have detected that the task is waiting for an event to resume it.
                    -- Do we want to yield the taskSequence right now to satisfy the event condition needed for the yielded task, or do we complete the rest of pendingTasks in order to maximize the amount of tasks done before yielding?
                    
                    local nextAction = self.checkEventFulfillment[task.resumeEvent]

                    nextAction(self) -- Either this will queue the task that fulfills resumeEvent, or it yields the taskSequence so that another yielding_object can try to satisfy the resumeEvent.
                end
            -- Here we need to process taskResult to determine how task yielded/terminated. Does it need to resume? What event does it need for resumeEvent? Is there any other important information stored in taskResult?
        end
    end

end

function taskSequence:registerTask(task, previousOutcome)
    -- Registers a task to its registeredOutcome
    -- Move task to the table self.tasks[task.registeredOutcome]
    self.tasks[previousOutcome] = nil
    self.tasks[task.registeredOutcome] = task --If the key doesn't exist, does this create the key?
end

function taskSequence:new()

    local obj = {}

    local obj.pendingTasks = {
        taskSequence = obj
    }

    --This is the constructor for taskSequence. I think we should extend the task class to make taskSequence. That way, we can yield the taskSequence and insert it into large taskSequences.

    -- Make sure to construct the coroutine to handle the tasks.

end